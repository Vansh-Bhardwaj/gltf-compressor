# Revamp Plan — gltf-compressor

This document captures the full plan to remove the compression features and revamp the repository into a visualizer platform.

## Goal

Replace the current glTF Compressor UI with a Visualizer site. The home page will present "portal" choices for different visualizers. Initial visualizers:

1. 3D Layer Visualizer — auto-generate ordered "steps" from GLB/GLTF data; each step isolates a mesh or group and animates its entry with camera focus.
2. Product Visualizer — polished product viewer with orbit controls, hotspots (click to see info), and an Explode mode that moves mesh parts outward into a spherical arrangement with tweened animations and professional feel.

We will remove client-side texture compression features (workers, compression UI, compression settings) as part of the cleanup.

---

## MVP Scope

- Home page with portal cards for the two visualizers.
- Model loader (reuse Dropzone) to load test models.
- A reusable `ModelCanvas` (refactor of `ModelView`) to host the three.js canvas, camera, lighting.
- Visualizer A (3D Layer) MVP: step extraction, play/next/pause controls, per-step camera animation and simple UI.
- Visualizer B (Product) MVP: orbit/pan/zoom, hotspots (HTML overlay or sprites), Explode button with distance slider and animated explosion/reset.

Non-goals for MVP:
- No texture compression or worker-based image encoding.
- No server-side or networked authoring. Hotspot authoring can be local-only or autogenerated.

---

## Data model (types)

- Step:
  - id: string
  - title?: string
  - description?: string
  - meshIds: string[]
  - cameraPosition?: [number, number, number]
  - cameraTarget?: [number, number, number]
  - animationParams?: { duration: number }

- Hotspot:
  - id: string
  - label: string
  - description?: string
  - worldPosition: [number, number, number]
  - relatedMeshIds: string[]

Store additions / removals (high-level):
- `useModelStore`: remove `textureCompressionSettingsMap` (or keep behind a flag). Add `visualizerSteps: Step[]`, `visualizerHotspots: Hotspot[]`, `activeStepId`.
- `useViewportStore`: add `isExploded: boolean`, `explodeAmount: number`, `cameraPreset`.

---

## Detailed Plan (tasks)

- [x] Create project revamp plan (this file)
- [ ] Audit compression code: identify all files and imports referencing compression and worker code.
- [ ] Design UI & data model: wireframes, component list, and props contracts.
- [ ] Scaffold pages and routing: `Home`, `VisualizerLayer`, `VisualizerProduct` and a `VisualizerShell` to host common controls.
- [ ] Implement Visualizer A: 3D Layer Visualizer (auto-step generation, timeline, animations).
- [ ] Implement Visualizer B: Product Visualizer (orbit controls, hotspots, explode animation).
- [ ] Refactor stores & types (update `useModelStore` and `useViewportStore`).
- [ ] Refactor/repurpose compression files & UI (prefer renaming to image-processing and feature-flagging before removing).
- [ ] Add tests & docs (smoke tests, update `PROJECT_STRUCTURE.md`, add `DEVELOPMENT.md`).
- [ ] Polish, accessibility & performance work (ARIA, keyboard, lazy-load heavy modules).

---

## Implementation notes & suggestions

- Keep react-three-fiber + drei and react-spring (already a dependency) for camera & mesh animations.
- Prefer `react-spring` or `@react-spring/web` for tweening explode animations — it's already in the project.
- Use `DocumentView` (from `@gltf-transform/view`) for live scene views; avoid re-parsing the glTF every frame.
- Step generation strategies:
  - Simple: every mesh/node becomes a step.
  - Grouped: group by parent node, material, or name prefixes.
- For Explode: compute mesh centroid, direction = (centroid - modelCentroid).normalize(); targetPosition = original + direction * explodeDistance * (1 + randomFactor). Animate positions with staggered delays.
- For hotspots: compute world position from mesh bounding box center. Render hotspots with Drei's `Html` or as small sprites and project to screen coordinates for HTML overlays.

---

## Theme engine & CMS integration (design notes)

We will add a theme engine so the site can change look and feel (colors, fonts, logo, spacing, and small layout toggles) and later be controlled via a CMS.

Goals for the theme engine:
- Allow per-client themes (color palettes, font stacks, logo / brand assets).
- Provide a runtime preview mode to swap themes in the dev UI without rebuilding.
- Persist theme selection locally (localStorage) and support server-side saving when a CMS is connected.
- Expose a simple token-based API to the rest of the app (CSS variables + TypeScript types).

Technical approach (recommended):
- Theme tokens: define a normalized token shape (colors, typography, spacing, logo references).
  - Example shape (TypeScript):
    - interface Theme { id: string; name: string; colors: { primary: string; background: string; surface: string; text: string; accent: string }; typography: { fontFamily: string; baseSize: number }; logo?: { url: string; alt?: string }; components?: { button?: { borderRadius?: string } } }
- Implement a `ThemeProvider` (already present) that reads a theme object and injects CSS variables on the root element. Use `next-themes` (already in deps) or keep a lightweight custom provider.
- CSS integration: use CSS variables (--color-primary, --bg, --text, --font-base) in Tailwind config and components via classnames and `style` fallback. Tailwind can read CSS variables, so keep utility classes and let tokens control runtime values.
- Fonts: load fonts dynamically when a theme requires a remote font (via <link rel="stylesheet"> or FontFace API). Lazy-load fonts on theme switch to avoid render-blocking.
- Logo & assets: store an asset URL in the theme token (when CMS connected this will come from media uploads). For now themes can include a `logoUrl` that components consume.

Runtime and CMS mapping:
- Theme CRUD (CMS): CMS will store themes as JSON objects matching the Theme interface. Fields: id, name, colors (map), typography (font family + weights), logo (asset URL), published boolean, previewImage.
- Preview workflow: admin/CMS pushes a preview theme token to a preview endpoint (or to the frontend via signed URLs). The frontend ThemeProvider should accept a `previewTheme` param to temporarily override the active theme.
- API contract sample (REST):
  - GET /api/themes -> list of themes
  - GET /api/themes/:id -> theme object
  - POST /api/themes/:id/preview -> set preview for current session (or return preview token)

Integration with stores and components:
- Add `useThemeStore` (zustand) or extend existing ThemeProvider to expose: `activeThemeId`, `activeTheme`, `setTheme(themeId)`, `setPreviewTheme(theme)`, `persistToServer(themeId)`.
- Components should consume tokens via CSS variables; also expose a small helper `theme.ts` to map tokens to React-friendly props when needed (e.g., icon color or computed contrast color).

Developer ergonomics & fallbacks:
- Provide a `themes/` folder with sample JSON theme files (e.g., `default.json`, `shopify.json`) used for local development.
- Fallback theme must always exist (hard-coded defaults in `ThemeProvider`) so UI never breaks.
- Add a small Theme Editor dev page (hidden behind a local-only flag) to tweak tokens and export JSON for the CMS.

Security & performance notes:
- Validate theme JSON server-side when CMS saves to prevent XSS injection (sanitize asset URLs and CSS values).
- Cache fonts and assets via CDN; use hashed filenames for cache-busting when needed.

Migration path (how we'll add this later):
1. Define Theme TypeScript interface and CSS variable naming convention.
2. Implement `ThemeProvider` that sets CSS variables and provides hooks to change theme.
3. Add local `themes/` JSON and a small dev Theme Editor page.
4. Wire CMS endpoints later to GET/PUT theme JSON and an admin UI to upload logos.

---

## Audit checklist (to find removals)

Search for references to:
- `textureCompression` / `textureCompressionWorker` / `compressTexture`
- `textureCompressionSettingsMap`
- `isBeingCompressed`, `compressedTexture`, `mimeType` on textures
- Any UI that mentions "Compress" or format/quality controls (in `TextureView`, `TextureViewStatus`, `SettingsView`)

Files likely to be removed or modified:
- `src/utils/textureCompression.ts`
- `src/utils/textureCompressionWorker.ts`
- `src/components/TextureView.tsx` (remove compression UI hooks)
- `src/components/TextureViewStatus.tsx` (remove compression messages)
- `src/components/SettingsView.tsx` (remove texture compression options)
- `src/stores/useModelStore.ts` (remove related store fields)
- Types in `src/types/types.ts` referencing compression settings

---

## Suggested immediate next step options

1. Audit code for compression references and produce a precise list of files + lines to edit (safe).  
2. Scaffold `Home` + `Visualizer` pages and a `ModelCanvas` skeleton (fast visible change).  
3. Create `src/DEVELOPMENT.md` with a short editing guide and pointers (docs).

Tell me which immediate step you want me to run and I'll start (I can scan the codebase for compression references now if you want).

---

## Contact & follow-up

When you're ready for implementation, I recommend we do the work in phased PRs:
- PR 1: Scaffold pages + ModelCanvas refactor (no behavior changes).
- PR 2: Visualizer A implementation and tests.
- PR 3: Visualizer B implementation and cleanup (remove compression).

